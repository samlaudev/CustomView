//
//  ScannerGraphics.m
//  DianDian
//
//  Created by Sam Lau on 10/6/15.
//  Copyright (c) 2015 DianDian. All rights reserved.
//
//  Generated by PaintCode (www.paintcodeapp.com)
//

#import "ScannerGraphics.h"

static const CGFloat kLeftRightMarginOffset = 60.0f;

@implementation ScannerGraphics

#pragma mark Initialization

+ (void)initialize
{
}

#pragma mark Drawing Methods

+ (void)drawScannerRectangleWithFrame: (CGRect)frame;
{
    //// General Declarations
    CGContextRef context = UIGraphicsGetCurrentContext();
    
    //// Color Declarations
    UIColor* color = [UIColor colorWithRed: 1 green: 1 blue: 1 alpha: 1];
    UIColor* noScanAreaColor = [UIColor colorWithRed: 0 green: 0 blue: 0 alpha: 0.452];
    UIColor* themeColor = [UIColor colorWithRed: 0.243 green: 0.525 blue: 0.894 alpha: 1];

    //// Rectangle Drawing
    UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRect: CGRectMake(CGRectGetMinX(frame) + kLeftRightMarginOffset, CGRectGetMinY(frame) + [self topMarginOffset:frame], [self scanAreaSize:frame], [self scanAreaSize:frame])];
    [color setStroke];
    rectanglePath.lineWidth = 1;
    [rectanglePath stroke];
    
    //// Top Rectangle Drawing
    UIBezierPath* topRectanglePath = [UIBezierPath bezierPathWithRect: CGRectMake(CGRectGetMinX(frame), CGRectGetMinY(frame), CGRectGetWidth(frame), [self topMarginOffset:frame])];
    [noScanAreaColor setFill];
    [topRectanglePath fill];


    //// Left Rectangle Drawing
    UIBezierPath* leftRectanglePath = [UIBezierPath bezierPathWithRect: CGRectMake(CGRectGetMinX(frame), CGRectGetMinY(frame) + [self topMarginOffset:frame], kLeftRightMarginOffset, [self scanAreaSize:frame] + 1.0f)];
    [noScanAreaColor setFill];
    [leftRectanglePath fill];


    //// Right Rectangle Drawing
    UIBezierPath* rightRectanglePath = [UIBezierPath bezierPathWithRect: CGRectMake(CGRectGetMinX(frame) + CGRectGetWidth(frame) - kLeftRightMarginOffset, CGRectGetMinY(frame) + [self topMarginOffset:frame], kLeftRightMarginOffset, [self scanAreaSize:frame] + 1.0f)];
    [noScanAreaColor setFill];
    [rightRectanglePath fill];

    //// Bottom Rectangle Drawing
    CGFloat bottomRectangleY = CGRectGetMinY(frame) + [self topMarginOffset:frame] + [self scanAreaSize:frame] + 1.0f;
    UIBezierPath* bottomRectanglePath = [UIBezierPath bezierPathWithRect: CGRectMake(CGRectGetMinX(frame), bottomRectangleY, CGRectGetWidth(frame), CGRectGetHeight(frame) - bottomRectangleY)];
    [noScanAreaColor setFill];
    [bottomRectanglePath fill];
    
    //// Top Left Corner
    {
        //// Rectangle 2 Drawing
        UIBezierPath* rectangle2Path = [UIBezierPath bezierPathWithRect: CGRectMake(CGRectGetMinX(frame) + kLeftRightMarginOffset, CGRectGetMinY(frame) + [self topMarginOffset:frame], 2, 15)];
        [themeColor setFill];
        [rectangle2Path fill];
        
        
        //// Rectangle 3 Drawing
        UIBezierPath* rectangle3Path = [UIBezierPath bezierPathWithRect: CGRectMake(CGRectGetMinX(frame) + kLeftRightMarginOffset, CGRectGetMinY(frame) + [self topMarginOffset:frame], 15, 2)];
        [themeColor setFill];
        [rectangle3Path fill];
    }

    //// Top Right Corner
    {
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, CGRectGetMinX(frame) + kLeftRightMarginOffset + [self scanAreaSize:frame], CGRectGetMinY(frame) + [self topMarginOffset:frame]);
        CGContextRotateCTM(context, 90 * M_PI / 180);
        
        
        
        //// Rectangle 4 Drawing
        UIBezierPath* rectangle4Path = [UIBezierPath bezierPathWithRect: CGRectMake(0, 0, 2, 15)];
        [themeColor setFill];
        [rectangle4Path fill];
        
        
        //// Rectangle 5 Drawing
        UIBezierPath* rectangle5Path = [UIBezierPath bezierPathWithRect: CGRectMake(0, 0, 15, 2)];
        [themeColor setFill];
        [rectangle5Path fill];
        
        
        
        CGContextRestoreGState(context);
    }

    //// Bottom Left Corner
    {
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, CGRectGetMinX(frame) + kLeftRightMarginOffset, CGRectGetMinY(frame) + [self topMarginOffset:frame] + [self scanAreaSize:frame] + 1.0f);
        CGContextRotateCTM(context, -90 * M_PI / 180);
        
        
        
        //// Rectangle 6 Drawing
        UIBezierPath* rectangle6Path = [UIBezierPath bezierPathWithRect: CGRectMake(0, 0, 2, 15)];
        [themeColor setFill];
        [rectangle6Path fill];
        
        
        //// Rectangle 7 Drawing
        UIBezierPath* rectangle7Path = [UIBezierPath bezierPathWithRect: CGRectMake(0, 0, 15, 2)];
        [themeColor setFill];
        [rectangle7Path fill];
        
        
        
        CGContextRestoreGState(context);
    }

    //// Bottom Right Corner
    {
        CGContextSaveGState(context);
        CGContextTranslateCTM(context, CGRectGetMinX(frame) + kLeftRightMarginOffset + [self scanAreaSize:frame], CGRectGetMinY(frame) + [self topMarginOffset:frame] + [self scanAreaSize:frame] + 1.0f);
        CGContextRotateCTM(context, 180 * M_PI / 180);
        
        
        
        //// Rectangle 8 Drawing
        UIBezierPath* rectangle8Path = [UIBezierPath bezierPathWithRect: CGRectMake(0, 0, 2, 15)];
        [themeColor setFill];
        [rectangle8Path fill];
        
        
        //// Rectangle 9 Drawing
        UIBezierPath* rectangle9Path = [UIBezierPath bezierPathWithRect: CGRectMake(0, 0, 15, 2)];
        [themeColor setFill];
        [rectangle9Path fill];
        
        
        
        CGContextRestoreGState(context);
    }

}

+ (CGFloat)scanAreaSize:(CGRect)frame
{
    return CGRectGetWidth(frame) - kLeftRightMarginOffset * 2.0;
    
}

+ (CGFloat)topMarginOffset:(CGRect)frame
{
    return (CGRectGetHeight(frame) - [self scanAreaSize:frame]) / 2.0f - 75.0f;
}

+ (CGRect)scanAreaFrame:(CGRect)frame
{
    return CGRectMake(CGRectGetMinX(frame) + kLeftRightMarginOffset,
                                        [self topMarginOffset:frame], [self scanAreaSize:frame], [self scanAreaSize:frame]);
}

+ (CGRect)rectOfInterest:(CGRect)frame
{
    CGRect cropRect = [self scanAreaFrame:frame];

    return CGRectMake(cropRect.origin.y / frame.size.height,
            cropRect.origin.x / frame.size.width,
            cropRect.size.height / frame.size.height,
            cropRect.size.width / frame.size.width);
}

@end
